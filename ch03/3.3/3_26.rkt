#lang planet neil/sicp

(define (log . w)
  (define (print . w)
    (display (car w))
    (display " ")
    (apply log (cdr w)))
  (if (null? w)
      (newline)
      (apply print w)))

(define (make-tree key value left right)
  (list key value left right))

(define (key-tree tree)
  (car tree))

(define (value-tree tree)
  (cadr tree))

(define (left-tree tree)
  (caddr tree))

(define (right-tree tree)
  (cadddr tree))

(define (empty-tree? tree)
  (null? tree))

(define (set-key-tree! key tree)
  (set-car! tree key))

(define (set-value-tree! value tree)
  (set-car! (cdr tree) value))

(define (set-left-tree! left tree)
  (set-car! (cddr tree) left))

(define (set-right-tree! right tree)
  (set-car! (cdddr tree) right))

(define (insert-tree! key value compare tree)
  (if (empty-tree? tree)
      (make-tree key value '() '())
      (let ((compared (compare key (key-tree tree))))
        (cond ((= 0 compared)
                (set-value-tree! value tree)
                tree)
              ((= -1 compared)
                (set-left-tree! (insert-tree! key value compare (left-tree tree))
                                tree)
                tree)
              ((= 1 compared)
                (set-right-tree! (insert-tree! key value compare (right-tree tree))
                                tree)
                tree)))))

(define (search-tree key compare tree)
  (if (empty-tree? tree)
      '()
      (let ((compared (compare key (key-tree tree))))
        (cond ((= 0 compared)
                tree)
              ((= -1 compared)
                (search-tree key compare (left-tree tree)))
              ((= 1 compared)
                (search-tree key compare (right-tree tree)))))))

(define (compare-string x y)
    ; debug
    ; (log "compare-string:" x)
    ; (log "compare-string:" y)
    (cond ((string=? x y)
            ; (log "compared:" 0)
            0)
          ((string>? x y)
            ; (log "compared:" 1)
            1)
          ((string<? x y)
            ; (log "compared:" -1)
            -1)))

(define (compare-symbol x y)
    (compare-string (symbol->string x)
                    (symbol->string y)))

(define (compare-number x y)
    (cond ((= x y)
            0)
          ((> x y)
            1)
          ((< x y)
            -1)))


(define (make-table compare)
    (let ((t '()))
        (define (empty?)
            (empty-tree? t))
        (define (insert! key value)
            (set! t (insert-tree! key value compare t))
            'ok)
        (define (lookup key)
            (let ((result (search-tree key compare t)))
                (if (null? result)
                    #f
                    (value-tree result))))
        (define (show)
          t)
        (define (dispatch m)
            (cond ((eq? m 'insert!)
                    insert!)
                  ((eq? m 'lookup)
                    lookup)
                  ((eq? m 'empty?)
                    (empty?))
                  ((eq? m 'show)
                    (show))
                  (else
                    (error "Unknow mode " m))))
        dispatch))

; test
(define t (make-table compare-symbol))
((t 'insert!) 'hello 10086)
((t 'insert!) 'world 'welcome)
(t 'show)
((t 'lookup) 'hello)
((t 'lookup) 'world)
((t 'lookup) 'yeah)
